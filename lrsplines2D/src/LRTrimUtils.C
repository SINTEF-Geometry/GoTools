/*
 * Copyright (C) 1998, 2000-2007, 2010, 2011, 2012, 2013 SINTEF ICT,
 * Applied Mathematics, Norway.
 *
 * Contact information: E-mail: tor.dokken@sintef.no                      
 * SINTEF ICT, Department of Applied Mathematics,                         
 * P.O. Box 124 Blindern,                                                 
 * 0314 Oslo, Norway.                                                     
 *
 * This file is part of GoTools.
 *
 * GoTools is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 *
 * GoTools is distributed in the hope that it will be useful,        
 * but WITHOUT ANY WARRANTY; without even the implied warranty of         
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with GoTools. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public
 * License, a covered work must retain the producer line in every data
 * file that is created or manipulated using GoTools.
 *
 * Other Usage
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the GoTools library without
 * disclosing the source code of your own applications.
 *
 * This file may be used in accordance with the terms contained in a
 * written agreement between you and SINTEF ICT. 
 */


#include "GoTools/lrsplines2D/LRTrimUtils.h"
#include "GoTools/geometry/Utils.h"
#include <iostream>
#include <fstream>

using namespace Go;
using std::vector;

#define DEBUG

int compare_u_par(const void* el1, const void* el2)
{
  if (((double*)el1)[0] < ((double*)el2)[0])
    return -1;
  else if (((double*)el1)[0] > ((double*)el2)[0])
    return 1;
  else
    return 0;
}

int compare_v_par(const void* el1, const void* el2)
{
  if (((double*)el1)[1] < ((double*)el2)[1])
    return -1;
  else if (((double*)el1)[1] > ((double*)el2)[1])
    return 1;
  else
    return 0;
}

//==============================================================================
LRTrimUtils::LRTrimUtils(std::vector<double>& points, 
			 int dim, int nmb_u, int nmb_v)
  : points_(points), dim_(dim), nmb_u_(nmb_u), nmb_v_(nmb_v)
//==============================================================================
{
  // Compute the domain corresponding to the point set
  int ki, kj;
  int del = dim_ + 2;
  for (ki=0; ki<2; ++ki)
    domain_[2*ki] = domain_[2*ki+1] = points_[ki];
  int nmb = (int)points_.size()/del;
  for (kj=1; kj<nmb; ++kj)
    for (ki=0; ki<2; ++ki)
      {
	domain_[2*ki] = std::min(domain_[2*ki], points_[kj*del+ki]);
	domain_[2*ki+1] = std::max(domain_[2*ki+1], points_[kj*del+ki]);
      }
}

//==============================================================================
LRTrimUtils::~LRTrimUtils()
//==============================================================================
{
}

//==============================================================================
void LRTrimUtils::computeTrimSeqs(int max_level, 
				  vector<vector<double> >& seqs)
//==============================================================================
{ 
  int del = dim_ + 2;
  int nmb_pts = (int)points_.size()/del;

  SubCloud cloud;
  cloud.setInfo(nmb_pts, 0, (int)points_.size(), domain_, domain_);
  computeTrimInfo(cloud, max_level, seqs);
}

//==============================================================================
void LRTrimUtils::distributePointCloud(int ix1, int ix2,
				       double domain[4],
				       vector<SubCloud>& sub_clouds)
//==============================================================================
{
  sub_clouds.resize(nmb_u_*nmb_v_);
  int del = dim_ + 2;

  double u_del = (domain[1] - domain[0])/(double)(nmb_u_);
  double v_del = (domain[3] - domain[2])/(double)(nmb_v_);

  // Sort points in v-direction
  int nmb_pts = (ix2 - ix1)/del;
  double *points = &points_[ix1];
  qsort(points, nmb_pts, del*sizeof(double), compare_v_par);
      
  // Distribute points into strips
  int ki, kj, kr;
  int pp0, pp1, pp2, pp3;
  int ppmax = ix2 - ix1;
  double upar, vpar;
  double subdomain[4];
  for (kr=0, ki=0, pp0=0, vpar=domain[2]+v_del; ki<nmb_v_; 
       ++ki, vpar+=v_del, pp0=pp1)
    {
      subdomain[2] = vpar - v_del;
      subdomain[3] = vpar;

      if (ki == nmb_v_-1)
	{
	  pp1 = ppmax;
	}
      else
	{
	  for (pp1=pp0; pp1<ppmax && points[pp1+1]<vpar; pp1+=del);
	}

      // Sort according to the u-parameter
      qsort(points+pp0, (pp1-pp0)/del, del*sizeof(double), compare_u_par);
	   
      for (kj=0, pp2=pp0, upar=domain[0]+u_del; kj<nmb_u_;
	   ++kj, upar+=u_del, pp2=pp3, ++kr)
	{
	  subdomain[0] = upar - u_del;
	  subdomain[1] = upar;

	  double bb[4];
	  bb[0] = subdomain[1];
	  bb[1] = subdomain[0];
	  bb[2] = subdomain[3];
	  bb[3] = subdomain[2];
	  
	  for (pp3=pp2; pp3<pp1 && points_[pp3]<upar; pp3+=del)
	    {
	      bb[0] = std::min(bb[0], points_[pp3]);
	      bb[1] = std::max(bb[1], points_[pp3]);
	      bb[2] = std::min(bb[2], points_[pp3+1]);
	      bb[3] = std::max(bb[3], points_[pp3+1]);
	    }
	  if (kj == nmb_u_-1)
	    {
	      for (; pp3<pp1; pp3+=del)
		{
		  bb[0] = std::min(bb[0], points_[pp3]);
		  bb[1] = std::max(bb[1], points_[pp3]);
		  bb[2] = std::min(bb[2], points_[pp3+1]);
		  bb[3] = std::max(bb[3], points_[pp3+1]);
		}
	    }
	  sub_clouds[kr].setInfo((pp3-pp2)/del, pp2+ix1, pp3+ix1, 
				 subdomain, bb);
	}
    }
}

//==============================================================================
void LRTrimUtils::setSubSeq(SubCloud& cloud,
			    vector<double>& seq)
//==============================================================================
{ 
  seq.resize(10);
  seq[0] = cloud.dom_[0];
  seq[1] = cloud.dom_[3];
  seq[2] = cloud.dom_[0];
  seq[3] = cloud.dom_[2];
  seq[4] = cloud.dom_[1];
  seq[5] = cloud.dom_[2];
  seq[6] = cloud.dom_[1];
  seq[7] = cloud.dom_[3];
  seq[8] = cloud.dom_[0];
  seq[9] = cloud.dom_[3];
}

//==============================================================================
void LRTrimUtils::computeTrimInfo(SubCloud& cloud,
				  int max_level,
				  vector<vector<double> >& seqs)
//==============================================================================
{ 
  if (max_level == 0)
    {
      vector<double> curr_seq;
      setSubSeq(cloud, curr_seq);
      seqs.push_back(curr_seq);
      return;
    }

  // Distribute current point cloud into sub clouds
  vector<SubCloud> sub_clouds;
  distributePointCloud(cloud.ix1_, cloud.ix2_, cloud.dom_,
		       sub_clouds);

  // Traverse the sub clouds and check whether they need to be processed
  // further
  int ki, kj, kr;
  double frac = 0.9;
  for (kr=0, kj=0; kj<nmb_v_; ++kj)
    {
      for (ki=0; ki<nmb_u_; ++ki, ++kr)
	{
	  if (sub_clouds[kr].nmb_pts_ == 0)
	    continue;  // No points in sub cloud. Not inside trimming loop
	  
	  vector<double> limitseq;  // Point sequences towards non-processed
	                            // sub clouds

	  // For each neighbour, check if it exists or if it contains no 
	  // points or contains points only in a part of the domain
	  int nmb_nolimits = 0;
	  if (sub_clouds[kr].limitedSupport(frac))
	    nmb_nolimits = 4;
	  else
	    {
	      if (ki==0 || sub_clouds[kr-1].nmb_pts_ == 0 ||
		  sub_clouds[kr-1].limitedSupport(frac))
		nmb_nolimits++;
	      else
		{
		  vector<double> bdseq;
		  sub_clouds[kr].leftBd(bdseq);
		  limitseq.insert(limitseq.end(), bdseq.begin(), bdseq.end());
		}
	      if (ki==nmb_u_-1 || sub_clouds[kr+1].nmb_pts_ == 0 ||
		  sub_clouds[kr+1].limitedSupport(frac))
		nmb_nolimits++;
	      else
		{
		  vector<double> bdseq;
		  sub_clouds[kr].rightBd(bdseq);
		  limitseq.insert(limitseq.end(), bdseq.begin(), bdseq.end());
		}
	      if (kj==0 || sub_clouds[kr-nmb_u_].nmb_pts_ == 0 ||
		  sub_clouds[kr-nmb_u_].limitedSupport(frac))
		nmb_nolimits++;
	      else
		{
		  vector<double> bdseq;
		  sub_clouds[kr].lowerBd(bdseq);
		  limitseq.insert(limitseq.end(), bdseq.begin(), bdseq.end());
		}
	      if (kj==nmb_v_-1 || sub_clouds[kr+nmb_u_].nmb_pts_ == 0 ||
		  sub_clouds[kr+nmb_u_].limitedSupport(frac))
		nmb_nolimits++;
	      else
		{
		  vector<double> bdseq;
		  sub_clouds[kr].upperBd(bdseq);
		  limitseq.insert(limitseq.end(), bdseq.begin(), bdseq.end());
		}
	    }
	      
	  if (nmb_nolimits == 0)
	      continue;  // Not a boundary cloud. Do not process further

	  // Recursively compute seqences of the trimming loops
#ifdef DEBUG
	  int del = dim_ + 2;
	  std::ofstream ofa("sub_cloud_curr.g2");
	  (void)ofa.precision(15);
	  ofa << "400 1 0 0" << std::endl;
	  ofa << sub_clouds[kr].nmb_pts_ << std::endl;
	  for (int kr1=0; kr1<sub_clouds[kr].nmb_pts_; ++kr1)
	    {
	      for (int kh1=0; kh1<del-1; ++kh1)
		ofa << points_[sub_clouds[kr].ix1_+kr1*del+kh1] << " ";
	      ofa << 0 << std::endl;
	    }
#endif
	  vector<vector<double> > seqs2;
	  computeTrimInfo(sub_clouds[kr], max_level-1, seqs2);

	  // Remove trim seqences adjacent to non processed sub clouds
	  if (limitseq.size() > 0)
	    removeFalseTrimSeqs(limitseq, seqs2);

#ifdef DEBUG
	  std::ofstream ofd("trim_seqs_curr.g2");
	  (void)ofd.precision(15);
	  for (int kr1=0; kr1<(int)seqs2.size(); ++kr1)
	    {
	      ofd << "410 1 0 0" << std::endl;
	      ofd << seqs2[kr1].size()/2-1 << std::endl;
	      for (int kh1=0; kh1<=(int)seqs2[kr1].size()-4; kh1+=2)
		{
		  ofd << seqs2[kr1][kh1] << " " << seqs2[kr1][kh1+1] << " " << 0 << " ";
		  ofd << seqs2[kr1][kh1+2] << " " << seqs2[kr1][kh1+3] << " " << 0 << std::endl;
		}
	    }
#endif		 
	  // Merge trimming sequences
	  mergeTrimSeqs(seqs, seqs2);
#ifdef DEBUG
	  std::ofstream off("trim_seqs.g2");
	  (void)off.precision(15);
	  for (int kr1=0; kr1<(int)seqs.size(); ++kr1)
	    {
	      off << "410 1 0 0" << std::endl;
	      off << seqs[kr1].size()/2-1 << std::endl;
	      for (int kh1=0; kh1<=(int)seqs[kr1].size()-4; kh1+=2)
		{
		  off << seqs[kr1][kh1] << " " << seqs[kr1][kh1+1] << " " << 0 << " ";
		  off << seqs[kr1][kh1+2] << " " << seqs[kr1][kh1+3] << " " << 0 << std::endl;
		}
	    }
	  int stop_break = 1;
#endif		 
	}
    }
}

//==============================================================================
void LRTrimUtils::removeFalseTrimSeqs(vector<double>& limitseqs,
				      vector<vector<double> >& seqs)
//==============================================================================
{ 
  if (limitseqs.size() == 0)
    return;  // No need to remove segments due to limit sequences towards
  // non-processed point cloudes

  double eps = 1.0e-12;  // A small number used as numeric tolerance
  size_t ki, kj, kr, kh, kb;
  for (ki=0; ki<seqs.size(); ++ki)
    {
      for (kj=0; kj<seqs[ki].size(); )
	{
	  // Compare parameter value with end point of limit sequence
	  for (kr=0; kr<limitseqs.size(); kr+=4)
	    {
	      double d1 = Utils::distance_squared(limitseqs.begin()+kr,
						  limitseqs.begin()+kr+2,
						  seqs[ki].begin()+kj);
	      double d2 = Utils::distance_squared(limitseqs.begin()+kr+2,
						  limitseqs.begin()+kr+4,
						  seqs[ki].begin()+kj);
	      if (d1 < eps || d2 < eps)
		{
		  // A match is found. Compute the extent
		  double dd = (d1 < eps) ? d2 : d1;
		  size_t ix = (d1 < eps) ? kr+2 : kr;

		  for (kh=kj+2; kh<seqs[ki].size(); kh+=2)
		    {
		      dd = Utils::distance_squared(limitseqs.begin()+ix,
						   limitseqs.begin()+ix+2,
						   seqs[ki].begin()+kh);
		      if (dd < eps)
			break;
		    }

		  if (kh < seqs[ki].size())
		    {
		      // Check intermediate points
		      for (kb=kj+2; kb<kh; kb+=2)
			{
			  Point vec1(limitseqs[kr+2]-limitseqs[kr],
				     limitseqs[kr+3]-limitseqs[kr+1]);
			  Point vec2(seqs[ki][kb]-limitseqs[kr],
				     seqs[ki][kb+1]-limitseqs[kr+1]);
			  vec1.normalize();
			  dd = (vec2 - (vec1*vec2)*vec1).length2();
			  if (dd > eps)
			    break;
			}

		      if (kb == kh)
			{
			  // A match is found. Remove piece and split
			  // the trim seqence if necessary
			  if (kj == 0)
			    seqs[ki].erase(seqs[ki].begin(), 
					   seqs[ki].begin()+kh);
			  else if (kh == seqs[ki].size() - 2)
			    seqs[ki].erase(seqs[ki].begin()+kj+2, seqs[ki].end());
			  else
			    {
			      vector<double> nseq(seqs[ki].begin()+kh,
						  seqs[ki].end());
			      seqs.push_back(nseq);
			      seqs[ki].erase(seqs[ki].begin()+kj+2, 
					     seqs[ki].end());
			    }
			  limitseqs.erase(limitseqs.begin()+kr,
					  limitseqs.begin()+kr+4);
			  break;  // loop: for (kr=0; kr<limitseqs.size(); ...
			}
		    }
		}
	    }
	  if (kr == limitseqs.size())
	    kj += 2; // No match found. Check next parameter pair
	}
    }
  for (ki=0; ki<seqs.size(); )
    {
      if (seqs[ki].size() == 0)
	seqs.erase(seqs.begin()+ki);
      else
	++ki;
    }
}


//==============================================================================
void LRTrimUtils::mergeTrimSeqs(vector<vector<double> >& seqs,
				vector<vector<double> >& seqs2)
//==============================================================================
{ 
  double eps = 1.0e-12; // A small number used as numeric tolerance

  int ki, kj, kr, kh;
  int kv, kw, ks, kt;

  // Remove double segments
  for (ki=0; ki<(int)seqs2.size(); ++ki)
    {
      for (kj=0; kj<(int)seqs2[ki].size(); kj+=2)
	{
	  for (kr=0; kr<(int)seqs.size(); ++kr)
	    {
	      for (kh=0; kh<(int)seqs[kr].size(); kh+=2)
		{
		  double dd = 
		    Utils::distance_squared(seqs[kr].begin()+kh,
					    seqs[kr].begin()+kh+2,
					    seqs2[ki].begin()+kj);
		  if (dd < eps)
		    {
		      // Equality in one point. Search for an interval
		      // equality. Adjacent sub group boundaries will
		      // have opposite direction
		      // Forward for seqs2
		      for (kv=kj+2, kw=kh-2; 
			   kv<(int)seqs2[ki].size() && kw>=0;
			   kv+=2, kw-=2)
			{
			  double dd2 =
			    Utils::distance_squared(seqs[kr].begin()+kw,
						    seqs[kr].begin()+kw+2,
						    seqs2[ki].begin()+kv);
			  if (dd2 >= eps)
			    break;
			}

		      // Backwards for seqs2
		      for (ks=kj-2, kt=kh+2;
			   ks>=0 && kt<(int)seqs[kr].size();
			   ks-=2, kt+=2)
			{
			  double dd2 =
			    Utils::distance_squared(seqs[kr].begin()+kt,
						    seqs[kr].begin()+kt+2,
						    seqs2[ki].begin()+ks);
			  if (dd2 >= eps)
			    break;
			}
		      
		      if (kv - ks > 4)
			{
			  // Remove double segment
			  if (ks < 0)
			    seqs2[ki].erase(seqs2[ki].begin(), 
					    seqs2[ki].begin()+kv-2);
			  else if (kv > (int)seqs2[ki].size())
			    seqs2[ki].erase(seqs2[ki].begin()+ks+4,
					    seqs2[ki].end());
			  else
			    {
			      vector<double> nseq(seqs2[ki].begin()+kv-2,
						  seqs2[ki].end());
			      seqs2.push_back(nseq);
			      seqs2[ki].erase(seqs2[ki].begin()+ks+4, 
					      seqs2[ki].end());
			    }
			}
		      if (kt - kw > 4)
			{
			  // Remove double segment
			  if (kw < 0)
			    seqs[kr].erase(seqs[kr].begin(), 
					   seqs[kr].begin()+kt-2);
			  else if (kt > (int)seqs[kr].size())
			    seqs[kr].erase(seqs[kr].begin()+kw+4,
					    seqs[kr].end());
			  else
			    {
			      vector<double> nseq(seqs[kr].begin()+kt-2,
						  seqs[kr].end());
			      seqs.push_back(nseq);
			      seqs[kr].erase(seqs[kr].begin()+kw+4, 
					     seqs[kr].end());
			    }
			}
		    }
		}
	    }
	}
    }

  // Clean up
  for (ki=0; ki<(int)seqs.size(); )
    {
      if (seqs[ki].size() <= 2) //== 0)
	seqs.erase(seqs.begin()+ki);
      else
	++ki;
    }

  for (ki=0; ki<(int)seqs2.size(); )
    {
      if (seqs2[ki].size() <= 2) //== 0)
	seqs2.erase(seqs2.begin()+ki);
      else
	++ki;
    }

#ifdef DEBUG
	  std::ofstream of1("trim_seqs_merge.g2");
	  (void)of1.precision(15);
	  for (int kr1=0; kr1<(int)seqs.size(); ++kr1)
	    {
	      of1 << "410 1 0 4 255 0 0 255" << std::endl;
	      of1 << seqs[kr1].size()/2-1 << std::endl;
	      for (int kh1=0; kh1<=(int)seqs[kr1].size()-4; kh1+=2)
		{
		  of1 << seqs[kr1][kh1] << " " << seqs[kr1][kh1+1] << " " << 0 << " ";
		  of1 << seqs[kr1][kh1+2] << " " << seqs[kr1][kh1+3] << " " << 0 << std::endl;
		}
	    }

	  for (int kr1=0; kr1<(int)seqs2.size(); ++kr1)
	    {
	      of1 << "410 1 0 4 0 255 0 255" << std::endl;
	      of1 << seqs2[kr1].size()/2-1 << std::endl;
	      for (int kh1=0; kh1<=(int)seqs2[kr1].size()-4; kh1+=2)
		{
		  of1 << seqs2[kr1][kh1] << " " << seqs2[kr1][kh1+1] << " " << 0 << " ";
		  of1 << seqs2[kr1][kh1+2] << " " << seqs2[kr1][kh1+3] << " " << 0 << std::endl;
		}
	    }
#endif

  // Join sequences
  if (seqs.size() == 0)
    seqs = seqs2;
  else
    {
      for (ki=0; ki<(int)seqs2.size(); ++ki)
	{

	  for (kr=0; kr<(int)seqs.size(); ++kr)
	    {
	      double dd1 =
		Utils::distance_squared(seqs[kr].begin(),
					seqs[kr].begin()+2,
					seqs2[ki].begin()+seqs2[ki].size()-2);
	      double dd2 =
		Utils::distance_squared(seqs2[ki].begin(),
					seqs2[ki].begin()+2,
					seqs[kr].begin()+seqs[kr].size()-2);
	      if (dd1 < eps)
		{
		  seqs2[ki].insert(seqs2[ki].end(), seqs[kr].begin()+2,
				   seqs[kr].end());
		  std::swap(seqs[kr], seqs2[ki]);
		  break;
		}
	      else if (dd2 < eps)
		{
		  seqs[kr].insert(seqs[kr].end(), seqs2[ki].begin()+2,
				  seqs2[ki].end());
		  break;
		}
	    }
	  if (kr == (int)seqs.size())
	    seqs.push_back(seqs2[ki]);
	}
    } 

}
